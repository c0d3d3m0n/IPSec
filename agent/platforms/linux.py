import os
import subprocess
import logging
from typing import Dict, Any
from .base import PlatformManager

logger = logging.getLogger(__name__)

class LinuxManager(PlatformManager):
    def __init__(self):
        self.conf_path = "/etc/ipsec.conf"
        self.secrets_path = "/etc/ipsec.secrets"

    def apply_policy(self, policy: Dict[str, Any]) -> bool:
        logger.info(f"Generating strongSwan config for policy: {policy['name']}")
        
        # Generate ipsec.conf content
        conf_content = self._generate_ipsec_conf(policy)
        
        # Generate ipsec.secrets content
        secrets_content = self._generate_ipsec_secrets(policy)
        
        try:
            # Write files (Requires root)
            # In a real scenario, we'd handle permissions carefully
            with open(self.conf_path, 'w') as f:
                f.write(conf_content)
            
            with open(self.secrets_path, 'w') as f:
                f.write(secrets_content)
                
            # Reload strongSwan
            subprocess.run(["ipsec", "restart"], check=True)
            logger.info("strongSwan restarted successfully.")
            return True
        except PermissionError:
            logger.error("Permission denied. Run as root.")
            return False
        except Exception as e:
            logger.error(f"Failed to apply Linux policy: {e}")
            return False

    def check_tunnel_status(self) -> bool:
        try:
            result = subprocess.run(["ipsec", "status"], capture_output=True, text=True)
            return "ESTABLISHED" in result.stdout
        except FileNotFoundError:
            logger.error("strongSwan (ipsec) command not found.")
            return False

    def _generate_ipsec_conf(self, policy: Dict[str, Any]) -> str:
        # Map API fields to strongSwan config
        # This is a simplified template
        
        left = "%defaultroute"
        leftsubnet = policy.get('local_network_cidr', '0.0.0.0/0')
        right = policy.get('remote_gateway', '%any') # Needs to be passed in policy or discovered
        rightsubnet = policy.get('remote_network_cidr', '0.0.0.0/0')
        
        ike = f"{policy.get('encryption_algorithm', 'aes256')}-{policy.get('integrity_algorithm', 'sha256')}-{policy.get('dh_group', 'modp2048')}!"
        esp = f"{policy.get('encryption_algorithm', 'aes256')}-{policy.get('integrity_algorithm', 'sha256')}!"
        
        config = f"""# Generated by Unified IPsec Agent
config setup
    charondebug="ike 1, knl 1, cfg 0"
    uniqueids=no

conn {policy['name']}
    authby={policy.get('auth_method', 'secret')}
    auto=start
    keyexchange={policy.get('ike_version', 'ikev2')}
    ike={ike}
    esp={esp}
    left={left}
    leftsubnet={leftsubnet}
    right={right}
    rightsubnet={rightsubnet}
    type=tunnel
"""
        return config

    def _generate_ipsec_secrets(self, policy: Dict[str, Any]) -> str:
        if policy.get('auth_method') == 'psk':
            psk = policy.get('psk_secret', 'default_psk')
            # Format: left_id right_id : PSK "secret"
            return f': PSK "{psk}"\n'
        return ""
